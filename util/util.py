
# ############################################################ #
# ####################### Dictionary ######################### #
# ############################################################ #


def defaultdict2(keys, default=''):
    return dict((k,default) for k in keys) 


def subdict(dct, keys): 
    '''>>> subdict(dict(a=1,b=2,c=3), ['a', 'c'])
    {'a': 1, 'c': 3}
    '''
    return dict((key, dct[key]) for key in keys)


def ordered_items(dct, keys):
    '''Return dct.items ordered by keys.
    keys = ['action', 'ok', 'client_url', 'client']
    d2 = {'action': 'UPLOAD', 'client_url': '216.84.220.194',
'client': 'dsi', 'ok': 'OK'}
    >>> ordered_items(d2, keys)
    [('action', 'UPLOAD'), ('ok', 'OK'), ('client_url',
'216.84.220.194'), ('client', 'dsi')]
    '''
    d2 = subdict(dct, keys)
    f = lambda (key, _): dict(zip(keys, range(len(keys))))[key]
    return sorted(d2.items(), key=f)


def dict_key_translate(dct, mapping, retain_unmapped=False):
    ''' 
    >>> mapping = [('a','x'), ('c', 'magoo')]
    >>> dict_key_translate(dict(a=1,b=2,c=3), mapping)
    {'x': 1, 'magoo': 3}

    >>> dict_key_translate(dict(a=1,b=2,c=3), mapping, True)
    {'x': 1, 'magoo': 3, 'b': 2}
    '''
    res = dict((new, dct[old]) for (old,new) in mapping)
    if not retain_unmapped:
        return res 
    # Leave unmentioned keys in place.
    mapped_keys = [a for a,b in mapping]
    unmapped_keys = set(dct.keys()).difference(mapped_keys)
    res.update( subdict(dct, unmapped_keys) )
    return res


def dict_transform(dct, func):
    '''
    Apply func to each dict value.
    '''
    new_dct = {}
    for key in dct:
        new_dct[key] = func(dct[key])
    return new_dct




# ############################################################ #
# ############################ List ########################## #
# ############################################################ #



def head_tail(lst):
    return (lst[0], lst[1:])
    # just like lisp would do #
    # except it applies to strings and any sequence


def tail_head(lst):
    return (lst[:-1], lst[-1])


def dups(lst):
    '''
    Return items that occur more than once.
    >>> dups(list('abcdeabcab'))
    ['a', 'b', 'c']
    '''
    return [item for item in set(lst) if lst.count(item) > 1]


def find_gaps(seq):
    '''
    Show gaps in seq by returning pairs surrounding missing elements.
    >>> find_gaps([1,2,3,5,6,7,22,23])
    [(3, 5), (7, 22)]
    '''
    gap = []
    for i in range(1, len(seq)):
        if seq[i] != seq[i-1]+1:
            gap.append((seq[i-1], seq[i]))
    return gap




def find_missing(seq):
    '''
    >>> find_missing([1,2,3,5,6,7,22,23])
    [4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]
    '''
    blah = [range(a+1,b) for (a,b) in find_gaps(seq)]
    return [item for sublist in blah for item in sublist]


def a_precedes_b_in(a, b, seq):
    '''
    >>> a_precedes_b_in('x', 'y', 'zzzzzzzzzzz')
    False
    >>> a_precedes_b_in('zzz', 'y', 'zzzzzzzzzzz')
    True
    >>> a_precedes_b_in('foo', 'bar', 'foobar')
    True
    >>> a_precedes_b_in('foo', 'bar', 'barfoo')
    False
    '''
    if a not in seq: return False
    if b not in seq: return True
    return seq.index(a) <= seq.index(b)




def partition(lst, func):
    '''
    Apply func to each element of lst.
    Return a dictionary with keys == the values generated by applying
func.
    and values == sublists of lst.
    '''
    from collections import defaultdict
    d = defaultdict(lambda:[])
    for thing in lst:
        d[func(thing)].append(thing)
    return d





# ############################################################ #
# ########################## filter ########################## #
# ############################################################ #




def grep(target, string_list, options=''):
    '''
    A clone of the familiar shell grep.  Instead of filtering stdin
or a
    file, filters a string_list.
    
    target : a string
    string_list : a list of strings
    options : in 'vinq'.  Same meanings as grep
        v : invert
        i : ignore case
        n : line numbers
        q : quiet (return tf)
    
    >>> string_list = 'AA bb cc ab ac xy'.split()
    >>> string_list = ['AA', 'bb', 'cc', 'ab', 'ac', 'xy']
    >>> grep('a', string_list)
    ['ab', 'ac']
    >>> grep('a', string_list, 'i')
    ['AA', 'ab', 'ac']
    >>> grep('a', string_list, 'iv')
    ['bb', 'cc', 'xy']
    >>> grep('a', string_list, 'v')
    ['AA', 'bb', 'cc', 'xy']
    >>> grep('b', string_list, 'n')
    [(1, 'bb'), (3, 'ab')]
    >>> grep('foo', string_list, 'q')
    False
    '''
    target = str(target)
    assert type(string_list) in (list, tuple, dict)
    assert type(string_list) not in (str, unicode, )
    f = lambda s: target in s
    v = lambda tf: tf
    i = lambda s: s
    if 'v' in options:
        v = lambda tf: not tf
    if 'i' in options:
        target = target.lower()
        i = lambda s: s.lower()
    fn = lambda s: v(f(i(s)))
    if 'q' in options:
        return any(s for s in string_list if fn(s))
    if 'n' in options:
        return [(n,s) for (n,s) in enumerate(string_list) if fn(s)]
    return [s for s in string_list if fn(s)]



def fetch_indices(seq,indices):
    '''
    >>> fetch_indices('abcdef', [3,5,1,1])
    ['d', 'c', 'b', 'b']
    '''
    return [seq[i] for i in indices]


def fetch_cols(csv_string,indices, ils='\n', ols='\n', ifs=',', ofs=','):
    '''
    >>> csv_string="""
    foo,bar,bat,rat
    moo,mar,cat,tat
    soo,sar,sat,sit
    """
    >>> print fetch_cols(csv_string, [2,0])
    bat,foo
    bat,moo
    sat,soo
    '''
    return ols.join(
        ofs.join(fetch_indices(line.split(ifs), indices))
            for line in csv_string.split(ils) if line)


# Complementary functions for the two above.  Remove selected
# columns.

def keepers(seq, indices_to_remove):
    '''Given a sequence and list of indices_to_remove, return the
indices
    that are KEPT. ie  set(range(len(seq))) - indices_to_remove
    '''
    return [i for i in range(len(seq)) if i not in indices_to_remove]
    return sorted(set(range(len(seq))) - set(indices_to_remove))

def remove_indices(seq,indices):
    return fetch_indices(seq, keepers(seq, indices))

def remove_cols(csv_string,indices, ils='\n', ols='\n', ifs=',',
ofs=','):
    row = [r for r in csv_string.split(ils) if r][0].split(ifs)
    return fetch_cols(csv_string, keepers(row, indices), ils, ols,
ifs, ofs )



def exec_docstring(func):
    try:
        exec(func.__doc__.replace('>>> ', '').replace('    ', ''))
    finally:
        globals().update(locals())


def split_list(lst, n):
    return [lst[i::n] for i in range(n)]


